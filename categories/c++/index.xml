<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on Krzysztof Kondrak&#39;s website</title>
    <link>https://kondrak.github.io/categories/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Krzysztof Kondrak&#39;s website</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 22 Aug 2016 22:40:24 +0000</lastBuildDate>
    
	<atom:link href="https://kondrak.github.io/categories/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>std::vector or C-style array?</title>
      <link>https://kondrak.github.io/posts/2016-08-22-stdvector-or-c-style-array/</link>
      <pubDate>Mon, 22 Aug 2016 22:40:24 +0000</pubDate>
      
      <guid>https://kondrak.github.io/posts/2016-08-22-stdvector-or-c-style-array/</guid>
      <description>&lt;p style=&#34;text-align: justify;&#34;&gt;
  I recently overheard a rather interesting statement concerning programming and thought I&amp;#8217;d share it with the world via a Tweet and a small counter example. This started an interesting discussion:
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rendering in VR using OpenGL instancing</title>
      <link>https://kondrak.github.io/posts/2016-05-21-rendering-in-vr-using-opengl-instancing/</link>
      <pubDate>Sat, 21 May 2016 15:01:38 +0000</pubDate>
      
      <guid>https://kondrak.github.io/posts/2016-05-21-rendering-in-vr-using-opengl-instancing/</guid>
      <description>&lt;p style=&#34;text-align: justify;&#34;&gt;
  TL;DR; &lt;a href=&#34;https://github.com/kondrak/oculusvr_samples/tree/master/InstancedRender&#34;&gt;download code sample from GitHub!&lt;/a&gt;
&lt;/p&gt;

&lt;p style=&#34;text-align: justify;&#34;&gt;
  In all of my VR applications thus far, I&amp;#8217;ve been using separate eye buffers for rendering, seeing it as a convenience. Recently, however, I started wondering how I could improve drawing times and reduce unnecessary overhead, so my attention turned toward single render target solution and how it could take advantage of instanced rendering. Here&amp;#8217;s a short summary of my results.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>My experiences going Rust from C&#43;&#43;</title>
      <link>https://kondrak.github.io/posts/2016-03-19-my-experiences-going-rust-from-c/</link>
      <pubDate>Sat, 19 Mar 2016 15:36:17 +0000</pubDate>
      
      <guid>https://kondrak.github.io/posts/2016-03-19-my-experiences-going-rust-from-c/</guid>
      <description>&lt;p style=&#34;text-align: justify;&#34;&gt;
  I&amp;#8217;ve been experimenting with &lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;Rust&lt;/a&gt; for over 6 months now. Most of that time I spent playing around with a &lt;a href=&#34;https://github.com/kondrak/rust64&#34;&gt;C64 emulator&lt;/a&gt; I wrote as a first project and initially I thought about creating a series on that topic. However, since there&amp;#8217;s so much reading material on the Internet about it already, I figured maybe it would be a good idea to write an intro for C/C++ programmers on Rust. But then I found &lt;a href=&#34;https://science.raphael.poss.name/rust-for-functional-programmers.html&#34;&gt;this article&lt;/a&gt;, so I decided to take a completely different route.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Sparse matrices and projection calculations</title>
      <link>https://kondrak.github.io/posts/2015-05-19-sparse-matrices-and-projection-calculations/</link>
      <pubDate>Tue, 19 May 2015 14:43:55 +0000</pubDate>
      
      <guid>https://kondrak.github.io/posts/2015-05-19-sparse-matrices-and-projection-calculations/</guid>
      <description>&lt;p style=&#34;text-align: justify;&#34;&gt;
  If you ever worked with high performance 3D applications you know that every cycle counts. One of the issues programmers try to solve is reducing computation time when dealing with matrices and vectors, especially if calculations are done very frequently each frame. Here&amp;#8217;s a little trick that can save you some memory and cycle counts when determining projection. Consider a typical projection matrix P:
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Templates and C-style array size</title>
      <link>https://kondrak.github.io/posts/2015-05-05-templates-and-c-style-array-size/</link>
      <pubDate>Tue, 05 May 2015 14:47:40 +0000</pubDate>
      
      <guid>https://kondrak.github.io/posts/2015-05-05-templates-and-c-style-array-size/</guid>
      <description>&lt;p style=&#34;text-align: justify;&#34;&gt;
  If you&amp;#8217;re dealing with templates a lot in your C++ code, then you&amp;#8217;re likely familiar with how template type deduction works. It&amp;#8217;s an extensive topic which I&amp;#8217;m not going to cover in detail here but while reading &lt;a href=&#34;https://kondrak.github.io/programming/effective-modern-c-by-scott-meyers/&#34;&gt;this book&lt;/a&gt; I found one aspect of it quite useful in my work.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Using C unions in high level code</title>
      <link>https://kondrak.github.io/posts/2015-05-05-using-c-unions-in-high-level-code/</link>
      <pubDate>Tue, 05 May 2015 12:08:59 +0000</pubDate>
      
      <guid>https://kondrak.github.io/posts/2015-05-05-using-c-unions-in-high-level-code/</guid>
      <description>&lt;p style=&#34;text-align: justify;&#34;&gt;
  I always considered the C &lt;code&gt;union&lt;/code&gt; to be highly underappreciated ugly-child that nobody cares about in high level programming. Not really meant for persistent storage (specific cases excluded), it&amp;#8217;s difficult to see any good use for such constructs, especially for beginner programmers. Unless you deal with compilers or close to the metal development, chances are you have barely used or spotted a &lt;code&gt;union&lt;/code&gt; in an application&amp;#8217;s runtime code. But unions can come in handy, sometimes in quite unexpected ways. I often forget about their applications, so hopefully this post will help me remember in the future.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Finding an alternative to std::bitset</title>
      <link>https://kondrak.github.io/posts/2015-05-04-finding-an-alternative-to-stdbitset/</link>
      <pubDate>Mon, 04 May 2015 23:25:44 +0000</pubDate>
      
      <guid>https://kondrak.github.io/posts/2015-05-04-finding-an-alternative-to-stdbitset/</guid>
      <description>&lt;p style=&#34;text-align: justify;&#34;&gt;
  In one of my games I ran into a seemingly simple problem: saving a puzzle state (ie. completed/not completed) for each of 105 available levels. Naturally first thing that came to mind was a static &lt;code&gt;bool&lt;/code&gt; array with required amount of entries &amp;#8211; both easy to maintain and write to disk without hassle:
&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>